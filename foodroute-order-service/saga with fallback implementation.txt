ğŸ“˜ FoodRoute â€“ Day-5 Summary
Resilience + Saga Orchestration
ğŸ¯ Objective of Day-5

Introduce failure handling and data consistency in a distributed microservices system by implementing:

Resilience patterns

Saga Orchestration between Order and Payment services

ğŸ§  Problem Addressed

In a distributed system:

Database transactions cannot span multiple services

Partial failures lead to data inconsistency

Example:

Order CREATED â†’ Payment FAILS â†’ Order stuck âŒ

âœ… Solution Implemented
1ï¸âƒ£ Saga Orchestration Pattern

Order Service acts as Saga Orchestrator

It controls the flow and state transitions

Handles success and failure explicitly

Order Service â†’ Payment Service
       â†³ success â†’ Order PAID
       â†³ failure â†’ Order CANCELLED (compensation)

2ï¸âƒ£ Order State Machine (Updated)
CREATED
â†’ PAYMENT_IN_PROGRESS
â†’ PAID

Failure:
â†’ CANCELLED


Order Service owns the state transitions.

3ï¸âƒ£ Transaction Management Rule

@Transactional is used only for local DB operations

External service calls are NOT part of DB transactions

Distributed rollback is replaced with compensating actions

4ï¸âƒ£ Compensation Logic

Instead of rollback:

If payment fails or times out â†’ cancel the order

Compensation ensures eventual consistency

5ï¸âƒ£ Resilience4j Integration

Used to protect Order Service from cascading failures.

Patterns Applied:

Circuit Breaker â†’ Stops calling failing Payment Service

Retry â†’ Handles transient failures

Fallback â†’ Triggers compensation logic

6ï¸âƒ£ Service-to-Service Communication

Order â†’ Payment uses WebClient

Uses Eureka service name, not hardcoded URLs

WebClient configured with:

@LoadBalanced

Spring Cloud LoadBalancer

7ï¸âƒ£ API Gateway Rule (Reinforced)

Gateway is only for external clients

Services do NOT call each other via Gateway

Order Service calls Payment Service directly using service discovery

ğŸ§ª Failure Scenarios Handled
Scenario	Outcome
Payment success	Order â†’ PAID
Payment failure	Order â†’ CANCELLED
Payment service down	Circuit opens, Order â†’ CANCELLED
Timeout / retry exhausted	Compensation triggered
ğŸ§  Key Learnings (Interview Gold)

Distributed transactions require Saga patterns

DB transactions â‰  distributed consistency

Compensation is a business rollback, not technical rollback

Resilience prevents cascading failures

Service discovery enables dynamic service resolution

ğŸ§‘â€ğŸ’¼ Interview-Ready Explanation

â€œWe implemented Saga Orchestration where Order Service acts as the coordinator. Local database transactions ensure consistency within a service, while compensating actions handle cross-service failures. Resilience4j prevents cascading failures using retries, circuit breakers, and fallbacks.â€

âœ… Day-5 Completion Criteria

âœ” Order-Payment Saga implemented
âœ” Compensation logic working
âœ” Resilience patterns applied
âœ” No hardcoded service URLs
âœ” Order state remains consistent under failures