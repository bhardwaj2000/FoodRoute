ğŸš€ Day-6 â€“ Step 5
Implement Outbox Pattern (Production-Grade Reliability)
ğŸ¯ Why We Need Outbox

Right now your flow is:

Save Order
â†’ Publish OrderCreatedEvent

âš ï¸ Problem scenario:

Order saved in DB
Application crashes
Event NOT published

System becomes inconsistent.

âœ… Outbox Pattern Fixes This

New flow:

Save Order
Save OutboxEvent (same DB transaction)
â†’ Background job publishes event
â†’ Mark OutboxEvent as processed

Now DB and event creation are atomic.

ğŸ— Architecture After Outbox
Order Service
  â”œâ”€â”€ orders table
  â”œâ”€â”€ outbox table
  â”œâ”€â”€ scheduler publishes events
  â””â”€â”€ Kafka
ğŸ§± Step 5.1 â€“ Create Outbox Table

In Order DB:

CREATE TABLE outbox (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    aggregate_id VARCHAR(50),
    event_type VARCHAR(100),
    payload TEXT,
    processed BOOLEAN DEFAULT FALSE,
    created_at DATETIME
);
ğŸ§± Step 5.2 â€“ Create Outbox Entity

In Order Service:

@Entity
@Table(name = "outbox")
public class OutboxEvent {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String aggregateId;
    private String eventType;

    @Lob
    private String payload;

    private boolean processed;

    private LocalDateTime createdAt;
}
ğŸ§± Step 5.3 â€“ Create Repository
public interface OutboxRepository extends JpaRepository<OutboxEvent, Long> {

    List<OutboxEvent> findByProcessedFalse();
}
ğŸ§± Step 5.4 â€“ Modify Order Creation

Replace direct Kafka publish.

Instead of:

kafkaTemplate.send("order-events", event);

Do this inside @Transactional method:

OrderCreatedEvent event = new OrderCreatedEvent(
        order.getOrderId(),
        order.getUserId(),
        order.getRestaurantId(),
        order.getTotalAmount()
);

OutboxEvent outbox = new OutboxEvent();
outbox.setAggregateId(order.getOrderId());
outbox.setEventType("OrderCreatedEvent");
outbox.setPayload(objectMapper.writeValueAsString(event));
outbox.setProcessed(false);
outbox.setCreatedAt(LocalDateTime.now());

outboxRepository.save(outbox);

Now:

Order + OutboxEvent saved in same transaction

No Kafka publish here.

ğŸ§± Step 5.5 â€“ Create Background Publisher

Enable scheduling in main class:

@EnableScheduling

Create:

@Component
public class OutboxPublisher {

    private final OutboxRepository repository;
    private final KafkaTemplate<String, String> kafkaTemplate;

    public OutboxPublisher(OutboxRepository repository,
                           KafkaTemplate<String, String> kafkaTemplate) {
        this.repository = repository;
        this.kafkaTemplate = kafkaTemplate;
    }

    @Scheduled(fixedDelay = 5000)
    public void publishEvents() {

        List<OutboxEvent> events = repository.findByProcessedFalse();

        for (OutboxEvent event : events) {
		OrderCreatedEvent eventObject =
        		objectMapper.readValue(
                	event.getPayload(),
                	OrderCreatedEvent.class
        		);

	kafkaTemplate.send("order-events",
        	event.getAggregateId(),
        	eventObject);


            event.setProcessed(true);
            repository.save(event);
        }
    }
}
ğŸ§ª Step 5.6 â€“ Test Outbox

1ï¸âƒ£ Stop Payment Service
2ï¸âƒ£ Create Order
3ï¸âƒ£ Check DB:

SELECT * FROM outbox;

You should see:

processed = false

4ï¸âƒ£ Start Payment Service
5ï¸âƒ£ Scheduler publishes
6ï¸âƒ£ processed = true

This proves reliability.

ğŸ§  What You Just Built

You now have:

âœ” Async Saga
âœ” Event-driven architecture
âœ” Reliable event publishing
âœ” Crash-safe design
âœ” Eventually consistent workflow

This is real production architecture.

ğŸ§  Interview-Level Explanation

â€œWe implemented the Outbox pattern to ensure that event publishing is transactionally consistent with database state changes. Events are persisted first and then asynchronously published to Kafka.â€

That answer alone signals senior backend engineer.