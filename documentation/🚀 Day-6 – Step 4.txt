ğŸš€ Day-6 â€“ Step 4
Order Service listens to PaymentCompletedEvent
ğŸ¯ Goal of Step-4

âœ” Order Service consumes payment-events
âœ” Order status updates to PAID or CANCELLED
âœ” No REST call involved
âœ” Full async choreography working

ğŸ§± Step 4.1 â€“ Create Event Class in Order Service

Create:

com.foodroute.order.service.event
PaymentCompletedEvent.java
public record PaymentCompletedEvent(
        String orderId,
        String paymentId,
        String status
) {}

âš  Must match JSON structure produced by Payment Service.

ğŸ§± Step 4.2 â€“ Configure Consumer Properly

In Order Service application.yml ensure:

spring:
  kafka:
    consumer:
      group-id: order-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.ErrorHandlingDeserializer
      properties:
        spring.deserializer.value.delegate.class: org.springframework.kafka.support.serializer.JsonDeserializer
        spring.json.value.default.type: com.foodroute.order.service.event.PaymentCompletedEvent
        spring.json.trusted.packages: "*"

Important:

Use different group-id from Payment Service

Use ErrorHandlingDeserializer

Explicitly define target class

ğŸ§± Step 4.3 â€“ Create Listener in Order Service

Create:

@Service
public class PaymentEventListener {

    private final OrderRepository orderRepository;

    public PaymentEventListener(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }

    @KafkaListener(topics = "payment-events")
    public void handlePaymentCompleted(PaymentCompletedEvent event) {

        System.out.println("Received PaymentCompletedEvent: " + event);

        Order order = orderRepository
                .findById(event.orderId())
                .orElseThrow(() -> new RuntimeException("Order not found"));

        if ("SUCCESS".equals(event.status())) {
            order.setStatus(OrderStatus.PAID);
        } else {
            order.setStatus(OrderStatus.CANCELLED);
        }

        orderRepository.save(order);
    }
}
ğŸ§ª Step 4.4 â€“ Test Full Async Flow

Restart everything:

1ï¸âƒ£ Kafka
2ï¸âƒ£ Eureka
3ï¸âƒ£ Order Service
4ï¸âƒ£ Payment Service

Now:

POST /orders

Expected flow:

Order saved (CREATED)
â†’ OrderCreatedEvent published
â†’ Payment consumes
â†’ Payment saved
â†’ PaymentCompletedEvent published
â†’ Order consumes
â†’ Order updated to PAID
ğŸ§  What You Just Achieved

You moved from:

Saga Orchestration (sync)

To:

Saga Choreography (async)

No direct calls between services.

Loose coupling achieved.

ğŸ§  Architecture After Step-4
Client
 â†’ Gateway
   â†’ Order Service
        â†³ publishes OrderCreatedEvent
   â†’ Payment Service
        â†³ consumes OrderCreatedEvent
        â†³ publishes PaymentCompletedEvent
   â†’ Order Service
        â†³ consumes PaymentCompletedEvent

Fully event-driven.

ğŸ§ª Verify in DB

Check:

SELECT status FROM orders;

It should change from:

CREATED â†’ PAID

Without any REST call.