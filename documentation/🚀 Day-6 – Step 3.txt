ğŸš€ Day-6 â€“ Step 3
Payment Service Consumes OrderCreatedEvent

Now we remove dependency on REST call.
Payment Service will react to event instead.

ğŸ¯ Goal of Step-3

âœ” Payment Service listens to order-events
âœ” Payment is created automatically
âœ” PaymentCompletedEvent is published
âœ” No WebClient involved

We are officially entering Saga Choreography.

ğŸ§± Step 3.1 â€“ Create Same Event Class in Payment Service

Create package:

com.foodroute.payment.service.event
OrderCreatedEvent.java
public record OrderCreatedEvent(
        String orderId,
        String userId,
        String restaurantId,
        BigDecimal amount
) {}

(Yes, duplicate for now. Later we can move to shared module.)

ğŸ§± Step 3.2 â€“ Create PaymentCompletedEvent
public record PaymentCompletedEvent(
        String orderId,
        String paymentId,
        String status
) {}
ğŸ§± Step 3.3 â€“ Add Kafka Listener in Payment Service

Create:

PaymentEventListener.java
@Service
public class PaymentEventListener {

    private final PaymentRepository paymentRepository;
    private final KafkaTemplate<String, Object> kafkaTemplate;

    public PaymentEventListener(PaymentRepository paymentRepository,
                                KafkaTemplate<String, Object> kafkaTemplate) {
        this.paymentRepository = paymentRepository;
        this.kafkaTemplate = kafkaTemplate;
    }

    @KafkaListener(topics = "order-events", groupId = "payment-group")
    public void handleOrderCreated(OrderCreatedEvent event) {

        System.out.println("Received OrderCreatedEvent: " + event);

        Payment payment = new Payment();
        payment.setPaymentId(UUID.randomUUID().toString());
        payment.setOrderId(event.orderId());
        payment.setAmount(event.amount());
        payment.setStatus("SUCCESS");
        payment.setCreatedAt(LocalDateTime.now());

        paymentRepository.save(payment);

        PaymentCompletedEvent completed =
                new PaymentCompletedEvent(
                        event.orderId(),
                        payment.getPaymentId(),
                        "SUCCESS"
                );

        kafkaTemplate.send("payment-events", completed);
    }
}

spring:
  kafka:
    consumer:
      group-id: payment-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.ErrorHandlingDeserializer
      properties:
        spring.deserializer.value.delegate.class: org.springframework.kafka.support.serializer.JsonDeserializer
        spring.json.value.default.type: com.foodroute.payment.service.event.OrderCreatedEvent
        spring.json.trusted.packages: "*"
ğŸ§ª Step 3.4 â€“ Test the Flow

1ï¸âƒ£ Start Kafka
2ï¸âƒ£ Start Eureka
3ï¸âƒ£ Start Order Service
4ï¸âƒ£ Start Payment Service

Now:

POST /orders

Expected flow:

Order Service â†’ publishes OrderCreatedEvent
Payment Service â†’ receives event
Payment saved in DB
PaymentCompletedEvent published
ğŸ§  What Just Happened?

We replaced:

Order â†’ REST â†’ Payment

With:

Order â†’ Kafka â†’ Payment

No direct dependency.

This is Saga Choreography.

ğŸ” Verify in DB

Check Payment table:

SELECT * FROM payments;

You should see payment record created automatically.

âœ… Step-3 Completion Checklist

âœ” Payment listener working
âœ” Payment saved from event
âœ” payment-events topic created
âœ” No WebClient call required
-----
we can define consumer-group-id in property file or @kafkaListner any place.

âœ… Define group-id in application.yml

âœ… OR define it in @KafkaListener

âŒ But if both are present, annotation overrides property

They can be different, but you must understand what that means.

In Our architecture:

Service	Group ID
Payment Service - foodroute-payment-group
Order Service	- foodroute-order-group
Delivery Service- foodroute-delivery-group

Each service should have its own group-id.

Why?

Because if they share same group:

group-id: foodroute-group

Then:

Order Service and Payment Service would split partitions

Only one would receive the event

That is WRONG for Saga choreography

ğŸš¨ Very Important Concept

If two different services use:

group-id: foodroute-group

Then:

They will compete

Only one service processes the message

Other service will NOT receive it

That breaks event-driven architecture.